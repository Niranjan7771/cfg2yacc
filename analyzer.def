# Analyzer Language Definition
# Demonstrates the new .def format with parse-tree construction

%%LEX
# Keywords
ANALYZE analyze
FROM from
WHERE where
CONTAINS contains
AND and
OR or
SHOW show

# Literals and identifiers
NUMBER [0-9]+
STRING \"[^\"]*\"
IDENTIFIER [a-zA-Z_][a-zA-Z0-9_]*

# Operators
EQUALS =
LPAREN \(
RPAREN \)
COMMA ,
SEMICOLON ;

# Whitespace (ignored)
WHITESPACE [ \t\n]+

%%YACC
# Main program structure
program -> statement_list
    { $$ = create_node("program", 1, $1); }

statement_list -> statement
    { $$ = create_node("statement_list", 1, $1); }
    | statement_list statement
    { $$ = create_node("statement_list", 2, $1, $2); }

statement -> analyze_stmt SEMICOLON
    { $$ = create_node("statement", 1, $1); }
    | show_stmt SEMICOLON
    { $$ = create_node("statement", 1, $1); }

# Analyze statement
analyze_stmt -> ANALYZE IDENTIFIER FROM source_expr where_clause
    { $$ = create_node("analyze_stmt", 3, $2, $4, $5); }

source_expr -> STRING
    { $$ = create_node("source_expr", 1, $1); }
    | IDENTIFIER
    { $$ = create_node("source_expr", 1, $1); }

where_clause -> WHERE condition
    { $$ = create_node("where_clause", 1, $2); }
    | 
    { $$ = create_leaf_node("where_clause", "empty"); }

# Show statement
show_stmt -> SHOW IDENTIFIER
    { $$ = create_node("show_stmt", 1, $2); }
    | SHOW STRING
    { $$ = create_node("show_stmt", 1, $2); }

# Conditions
condition -> simple_condition
    { $$ = create_node("condition", 1, $1); }
    | condition AND simple_condition
    { $$ = create_node("condition", 3, $1, $2, $3); }
    | condition OR simple_condition
    { $$ = create_node("condition", 3, $1, $2, $3); }

simple_condition -> IDENTIFIER CONTAINS STRING
    { $$ = create_node("simple_condition", 3, $1, $2, $3); }
    | IDENTIFIER EQUALS STRING
    { $$ = create_node("simple_condition", 3, $1, $2, $3); }
    | IDENTIFIER EQUALS NUMBER
    { $$ = create_node("simple_condition", 3, $1, $2, $3); }
    | LPAREN condition RPAREN
    { $$ = create_node("simple_condition", 1, $2); }
